{
  "name": "编写向前兼容的Python代码",
  "tagline": "",
  "body": "# 编写向前兼容的Python2代码\r\n\r\n\r\n\r\n最近一些需求开始接触Python，由于使用的第三方框架的限制，一直都在2.7的版本上活动。前一段时间看了一篇文章，讲CTO最重要的一个素质就是具备强烈的“还债”意识，便意识到我现在为了自己方便，没准也是为未来埋下一颗定时炸弹。\r\n\r\n众所周知Python什么都好，就是Python2和Python3之间的不兼容问题让人头大。除了不兼容，目前使用Python3的最大问题是没有像Python2那么多的支持库，或者说把目前Python2的支持库导入Python3要花费巨量的工作。所以我还是选择了Python2的版本，但是为了以后自己“还债”能轻松一些，我这几天抽空查了些资料，并把所得写在这里。\r\n\r\n以下这些建议适用于刚开始开发的Python2工程，在一开始做好这些准备，日后决定升级到Python3时会节省很多精力。\r\n\r\n## 不要低于2.6\r\n\r\n如果你正在开始一个新项目，不要低于2.6版本。从这个版本增加了许多让你有今后可以更容易升级到Python3的特性。如果你的新项目没必要支持更老版本Python，那么你的代码里现在添加一些明确的选项，就可以使用很多Python3的功能。\r\n\r\n在代码开始引入`__future__`模块，按照官方的说法，在这个模块中存在的特性最终都将成为Python语言标准的一部分，因此建议从现在开始在`__future__`中import使用以下项目：\r\n\r\n* `division`，精确除法。最好在所有Python2中导入精确除法，这样你不必在不同的文件中不得不是不是回到文件头看究竟是那种除法在活动。因为在python3中，精确除法是唯一默认，所以如果你正要开始一个新工程，建议你最好现在就用起来，而且是全部用起来。\r\n* `absolute_import`，绝对地址导入。这是最重要的一个。再也不会有 `from xml import bar` 时会`import`进来一个和你当前代码同级.xml文件了，现在只需要简单地`from .xml import bar`就能得到你想要的。歧义更少也更好用了。\r\n\r\n关于把`print`作为函数的未来导入，我建议先不用它，以防造成歧义。尤其是所有的编辑器都会把它作为保留字进行高亮。我们要极力避免同样的事物在不同的文件中有不同的行为。再加上`print`在2.6已经可以支持作为函数使用了，运行2to3也会给出兼容性提示，所有也没有必要强行使用`print`的future导入。\r\n\r\n虽然看起来很吸引人，但是`unicode_literals`的未来导入也不建议用。因为我们使用的所有API很可能要为此改变它支持的字符串类型。当然在某些地方这个特性导入是有用的，更多是仅限于那些低版本的接口和库，然而它们升到2.6以后自己会使用这个导入。为了使用`b'foo'`这样的字面值你也不需要特殊导入，它在Python2里就是可用的，而且可以防止2to3错误地把它转换为unicode。\r\n\r\n## 文件IO与Unicode\r\n\r\n文件IO在Python3中变化很大。好消息是如果你正在开发新工程，你可以明确指定Unicode来节省很多麻烦。\r\n\r\n如果你处理文本数据，使用`codecs.open`功能来打开文件。一般情况下记得使用utf-8，除非是Unicode独有的定义或操作。对于二进制IO要保证使用`'rb'`打开而不是`'r'`，当然在window环境时需要合适的支持。\r\n\r\n如果你处理字节数据，记得标记为`b'foo'`而非`'foo'`，这样能告诉2to3不要吧这些字面值转化为Unicode。在2.x版本中，要留意下面的不同：\r\n\r\n    >>> b'foo'\r\n    'foo'\r\n    >>> b'foo'[0]\r\n    'f'\r\n    >>> b'foo' + u'bar'\r\n    u'foobar'\r\n    >>> list(b'foo')\r\n    ['f', 'o', 'o']\r\n\r\n而在Python3中处理结果则是：\r\n\r\n    >>> b'foo'[0]\r\n    102\r\n    >>> b'foo' + 'bar'\r\n    Traceback (most recent call last):\r\n      File \"<stdin>\", line 1, in <module>\r\n    TypeError: can't concat bytes to str\r\n    >>> list(b'foo')\r\n    [102, 111, 111]\r\n    Traceback (most recent call last):\r\n      File \"<stdin>\", line 1, in <module>\r\n    TypeError: can't concat bytes to str\r\n\r\n作为兼容代码，你可以这么做：\r\n\r\n    >>> b'foo'[0:0 + 1]\r\n    b'f'\r\n    >>> b'foo' + 'bar'.encode('latin1')\r\n    b'foobar'\r\n    >>> to_charlist = lambda x: [x[c:c + 1] for c in range(len(x))]\r\n    >>> to_charlist(b'foo')\r\n    [b'f', b'o', b'o']\r\n\r\n## 2to3，安全第一\r\n\r\n2to3是个好东西，但你还是要小心一些，因为使用2to3转换中好多东西可能适得其反，——其中有些功能仍有bug，有些需要你足够的理解才能保证可行。以下是一些例子：\r\n\r\n#### 字符串的递归错误\r\n\r\n许多人会在python2中写下面这样的代码：\r\n\r\n    class Foo(object):\r\n        def __str__(self):\r\n            return unicode(self).encode('utf-8')\r\n        def __unicode__(self):\r\n            return u'Hello World'\r\n\r\n2to3会假定的api不兼容unicode，然后把你的代码转化成这样：\r\n\r\n    class Foo(object):\r\n        def __str__(self):\r\n            return str(self).encode('utf-8')\r\n        def __unicode__(self):\r\n            return 'Hello World'\r\n\r\n这就错了，第一这样Python3代码里里根本就没有用到`__unicode__`，第二`__str__`递归调用了自己，在别处初始化`Foo`时会报`runtime error`。解决这个问题，需要下一个2to3的第三方修正程序，或者自己写一个小小的帮助类：\r\n\r\n    import sys\r\n    \r\n    class UnicodeMixin(object):\r\n        if sys.version_info > (3, 0):\r\n            __str__ = lambda x: x.__unicode__()\r\n        else:\r\n            __str__ = lambda x: unicode(x).encode('utf-8')\r\n    \r\n    class Foo(UnicodeMixin):\r\n        def __unicode__(self):\r\n            return u'Hello World'\r\n\r\n这样虽然你在Python3代码里仍然还有`__unicode__`方法，但人畜无害。当某天你决定放弃对Python2支持，你只需要遍历一遍`UnicodeMixin`的所有子类，把`__unicode__`改成`__str__`，然后把这个帮助类删除就好了。\r\n\r\n#### 字符串比较\r\n\r\n下面这个问题，在Python2里是正确的：\r\n\r\n    >>> 'foo' == u'foo'\r\n    True\r\n\r\nPython3则是：\r\n\r\n    >>> b'foo' == 'foo'\r\n    False\r\n\r\n雪上加霜的是Python2和Python3对这样的情况连个warning都不给。这里提供一个帮助模组unicode_nazi，通过引入它，下次处理到unicode和字节字符混合操作时，就会得到提示。\r\n\r\n    >>> import unicodenazi\r\n    >>> u'foo' == 'foo'\r\n    __main__:1: UnicodeWarning: Implicit conversion of str to unicode\r\n    True\r\n\r\n但是要记住这个模组有时候是很烦人的，而且需要一定的运行花费。\r\n\r\n##### 总之：2to3工具的转换要谨慎，甚至可以把它当做是一个兼容性检查的工具，然后根据它的输出结果手动修改代码。\r\n\r\n## 字符串到底是什么\r\n\r\n下面这个表，左侧是python2里作为字节字符串类型出现的地方，右侧是对应的地方在python3里的实际类型。\r\n\r\n\r\n\r\n类型|Python3中的类型`(unicode==str)`\r\n---|---\r\nidentifiers 标识符|unicode\r\nDocstrings 文档字符串|unicode\r\n`__repr__`|unicode\r\n字典中字符串类型的键|unicode\r\nWSGI的environment键|unicode\r\nHTTP的header值，WSGI的environment值|unicode，仅限于ASCII 3.1以及latin1 3.2\r\nURL|unicode，但是有的API也能接受字节字符串。特别提醒：你的URL必须是UTF-8编码才能获取所有的标准库支持。\r\n文件名|unicode或字节。大部分API都能同时接受两者，但不支持互相转换。\r\n二进制内容|字节或字节数组。注意：第二种类型是不定的。所以要意识到自己可以有一种字面字符串又不定的对象。\r\nPython代码|unicode。你如果想把你的源码转为可执行对象的话，要自己解码。\r\n\r\n## Latin1的特殊性\r\n\r\n在一些场景下（举个例子WSGI）你使用的unicode字符串必须属于latin1子集，这是因为HTTP本身在编码的规则上就不明确，所以用latin1来作为一种明确且安全的约定方式。如果说通信的两端都在你的处理范围内（比如cookies操作），你当然可以随自己喜欢用utf-8甚至其他。如何将字符值限制为latin1呢？在Python3（而且只需在Python3）中进行以下操作：\r\n\r\n    return cookie_value.encode('utf-8').decode('latin1')\r\n\r\n除此之外，还有种方式是把utf-8编码为unicode，然后WSGI自己会把编码转为latin1，这样其实相当于把错误的utf-8值转化为latin1发送出去，然后接收的时候按顺序反着来一遍，也能得到正确的结果。\r\n\r\n当然这个方法比较丑陋，这也解释了为什么你直接把utf-8直接放在header里是可行的。并且只有cookies的header可以这么玩。不管怎么说这种做法都显得不可靠。\r\n\r\n另一个WSGI会出问题的地方是 `PATH_INFO / SCRIPT_NAME` 元组，不过你用Python3的时候，框架自身会帮你解决这个问题。\r\n\r\n地址：[http://lucumr.pocoo.org/2011/1/22/forwards-compatible-python/](http://lucumr.pocoo.org/2011/1/22/forwards-compatible-python/)",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}
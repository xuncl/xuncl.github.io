<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Python守护线程研究 by xuncl</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Python守护线程研究</h1>
      <h2 class="project-tagline"></h2>
    </section>

    <section class="main-content">
      <h1>
<a id="python-守护线程研究" class="anchor" href="#python-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%A0%94%E7%A9%B6" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Python 守护线程研究</h1>

<h3>
<a id="python的线程是python自己实现的还是系统实现的" class="anchor" href="#python%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%98%AFpython%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%BF%98%E6%98%AF%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E7%9A%84" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>python的线程是python自己实现的还是系统实现的？</h3>

<p>python线程其实是系统线程。
一些操作系统（比如linux）能给出所有已经跑起来的python线程列表，这说明python线程是基于操作系统的，在其他操作系统里，你可能在查看进程列表时看不到正在跑的线程。
如果所有的非守护进程结束了，整个进程就会停止。此时，所有的守护线程就会被终止。所以守护线程是整个进程的一部分，但是无法阻止进程停止（普通线程可以）。守护线程是纯python实现。一个进程在<code>_exit</code>方法被调用后就会终止，届时所有的进程都会被杀死，当主线程终止时（或<code>sys.exit</code>被调用），python解释器会查看是不是还有非守护线程活着，如果没有，它就会调用<code>_exit</code>，否则就等费守护先成退出。</p>

<p>下面探讨守护线程的问题：守护线程的标志位是用纯python实现的，通过<code>threading</code>模组，当模组导入后，一个Thread对象就建立起来代替了主线程，并且它的<code>_exitfunc</code>方法被钩子<code>atexit</code>注册了。
这个函数的源码：</p>

<pre><code>class _MainThread(Thread):

    def _exitfunc(self):
        self._Thread__stop()
        t = _pickSomeNonDaemonThread()
        if t:
            if __debug__:
                self._note("%s: waiting for other threads", self)
        while t:
            t.join()
            t = _pickSomeNonDaemonThread()
        if __debug__:
            self._note("%s: exiting", self)
        self._Thread__delete()
</code></pre>

<p>这个函数被python解释器调用时机为：<code>sys.exit</code>调用时或者主线程终止时。这个方法结束后，解释器会调用系统的<code>_exit</code>函数.当<code>_exit</code>调用后，操作系统会终止这个进程里的所有线程，然后终止进程。Python在存在非守护线程存活时不会调用<code>_exit</code>函数。</p>

<h3>
<a id="所有的线程都是进程的一部分" class="anchor" href="#%E6%89%80%E6%9C%89%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%83%BD%E6%98%AF%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>所有的线程都是进程的一部分。</h3>

<p>我曾以为守护线程不属于进程的一部分（见python官方解释），这其实是错的， 对操作系统来说，一个进程是许多线程的集合，每个线程在操作系统看来都是一样的（对操作系统来说，主线程没什么特别的，他只是在运行结束后最后调用<code>_exit</code>函数而已）。而且操作系统也不认识守护线程，这些都是python自己的概念。
python解释器使用原生线程来实现python的线程，只是记录了每个线程怎么创建的。解释器通过<code>atexit</code>钩子保证了<code>_exit</code>只会在没有非守护线程时结束，文档中的“这个python”程序，指的就是整个进程。</p>

<p>下面的代码能帮助理解普通线程和守护线程的区别：</p>

<pre><code>import sys
import time
import threading

class WorkerThread(threading.Thread):

    def run(self):
        while True:
            print 'Working hard'
            time.sleep(0.5)

def main(args):
    use_daemon = False
    for arg in args:
        if arg == '--use_daemon':
            use_daemon = True
    worker = WorkerThread()
    worker.setDaemon(use_daemon)
    worker.start()
    time.sleep(1)
    sys.exit(0)

if __name__ == '__main__':
    main(sys.argv[1:])
</code></pre>

<p>如果执行这段代码时加上参数<code>--use_daemon</code>，你会看到程序只打印了几行<code>working hard</code>，否则不加参数，程序不会停下来。不加<code>--use_daemon</code>标记时，即使主程序结束了整个程序也不会停下。</p>

      <footer class="site-footer">

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
